'''
Created on Nov 8, 2010

@author: jee
'''
from django.core.management.base import BaseCommand, CommandError
from optparse import make_option
import os
import subprocess
import signal
import time

if os.name == 'nt':    
    DEFAULT_PYTHON = 'C:/Python26/python.exe'
else:
    DEFAULT_PYTHON = '/usr/local/bin/python2.6'
    
DEFAULT_WORKER_NUM = 2
DEFAULT_PID_FILE = './worker_pids'
class Command(BaseCommand):
    help_text = ' spawns beanstalk_workers.'
    option_list = BaseCommand.option_list + (
        make_option('--python',
            action='store',
            dest='python',
            default=DEFAULT_PYTHON,
            help='Path to the python executable. (default:%s)' % DEFAULT_PYTHON),
        make_option('-n',
            action='store',
            dest='number',
            type=int,
            default=DEFAULT_WORKER_NUM,
            help='Number of beanstalk_worker to spawn. (default:%d)' % DEFAULT_WORKER_NUM),
        make_option('--pid',
            action='store',
            dest='pidfile',
            default=DEFAULT_PID_FILE,
            help='file to store pid to. (default:%s)' % DEFAULT_PID_FILE),
        # behavior modifying flags.
        make_option('-k', '--kill',
            action='store_true',
            dest='kill',
            help='Only kill the existing workers.'),
        make_option('-r', '--restart',
            action='store_true',
            dest='restart',
            help='Restart the workers.'),
    )
    __doc__ = help_text
    def handle(self, *args, **kwargs):
        if kwargs['kill']:
            # only kill.
            self.handle_kill(*args, **kwargs)
        elif kwargs['restart']:
            self.handle_kill(suppress_no_pid=True, * args, **kwargs)
            time.sleep(1)
            self.handle_start(*args, **kwargs)
        else:
            self.handle_start(*args, **kwargs)
        print "Finished."
            
    def handle_kill(self, suppress_no_pid=False, *args, **kwargs):
        print "Killing the workers..."
        pidfile = kwargs['pidfile']
        if not os.path.isfile(pidfile):
            msg = "PID file %s does not exist. cannot kill." % pidfile
            if suppress_no_pid:
                print msg
                return
            else:
                raise CommandError(msg)
        with open(pidfile, 'r') as f:
            for line in f:
                pid = int(line)
                if os.name == 'nt':
                    import ctypes
                    PROCESS_TERMINATE = 1
                    handle = ctypes.windll.kernel32.OpenProcess(PROCESS_TERMINATE, False, pid)
                    ctypes.windll.kernel32.TerminateProcess(handle, -1)
                    ctypes.windll.kernel32.CloseHandle(handle)
                else:
                    try:
                        os.kill(pid, signal.SIGTERM)
                    except OSError, e:
                        print e
                print "Killed: %d" % pid
            f.close()
        # sleep before removing file to give OS a time.
        time.sleep(1)
        os.remove(pidfile)

    def handle_start(self, *args, **kwargs):
        print "Starting the workers..."
        pidfile = kwargs['pidfile']
        if os.path.isfile(pidfile):
            raise CommandError("PID file %s already exists. either run kill (-k) or manually delete the file." % pidfile)
        with open(pidfile, 'w') as f:
            for _ in range(kwargs['number']):
                pid = self._spawn(*args, **kwargs).pid
                print "Started: %d" % pid
                f.write(str(pid))
                f.write('\n')
        
    def _spawn(self, *args, **kwargs):
        ''' Spawns a beanstalk_worker. Returns Popen object.'''
        python = kwargs['python']
        cmds = [python, 'manage.py', 'beanstalk_worker']
        if kwargs['pythonpath'] is not None:
            cmds += ['--pythonpath', kwargs['pythonpath']]
        devnull = self.null_device('w')
        p = subprocess.Popen(cmds, stdout=devnull, stderr=subprocess.STDOUT)
        return p

    def null_device(self, flags):
        try:
            # POSIX
            return open('/dev/null', flags)
        except Exception:
            pass
        
        try:
            # Windows
            return open('NUL', flags)
        except Exception:
            pass
        
        raise Exception("Cannot create NUL device.")
